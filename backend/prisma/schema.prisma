generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String       @id @default(uuid())
  email        String       @unique
  name         String?
  passwordHash String?
  isAdmin      Boolean      @default(false)
  blocked      Boolean      @default(false)
  inventories  Inventory[]  @relation("OwnerInventories")
  items        Item[]       @relation("UserItems")
  comments     Comment[]
  likes        Like[]
  accesses     Access[]
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

model Inventory {
  id            String       @id @default(uuid())
  title         String
  description   String?      @db.Text
  categoryId    String?
  category      Category?    @relation(fields: [categoryId], references: [id])
  imageUrl      String?
  tags          String[]
  ownerId       String
  owner         User         @relation("OwnerInventories", fields: [ownerId], references: [id])
  fields        Field[]
  items         Item[]
  accessList    Access[]
  comments      Comment[]
  isPublic      Boolean      @default(false)
  customIdParts CustomIdPart[]
  version       Int          @default(1) // optimistic locking
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model Field {
  id          String    @id @default(uuid())
  inventoryId String
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  name        String
  type        FieldType
  title       String
  visible     Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

enum FieldType {
  STRING
  NUMBER
  DATE
  BOOLEAN
  SELECT
  TEXT      // multi-line text field
  LINK      // image/document link
}

model Item {
  id          String    @id @default(uuid())
  inventoryId String
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  userId      String
  user        User      @relation("UserItems", fields: [userId], references: [id])
  customId    String
  values      Json
  version     Int       @default(1) // optimistic locking
  comments    Comment[]
  likes       Like[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([inventoryId, customId])
}

model Access {
  id          String    @id @default(uuid())
  inventoryId String
  inventory   Inventory @relation(fields: [inventoryId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  canWrite    Boolean   @default(false)
  createdAt   DateTime  @default(now())
}

model Comment {
  id          String    @id @default(uuid())
  content     String    @db.Text // Markdown-friendly
  inventoryId String?
  inventory   Inventory? @relation(fields: [inventoryId], references: [id])
  itemId      String?
  item        Item?     @relation(fields: [itemId], references: [id])
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  createdAt   DateTime  @default(now())
}

model Like {
  id       String   @id @default(uuid())
  itemId   String
  item     Item     @relation(fields: [itemId], references: [id])
  userId   String
  user     User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@unique([itemId, userId]) // prevent multiple likes by same user
}

model Category {
  id          String      @id @default(uuid())
  name        String      @unique
  inventories Inventory[]
}

model CustomIdPart {
  id          String       @id @default(uuid())
  inventoryId String
  inventory   Inventory    @relation(fields: [inventoryId], references: [id])
  type        CustomIdType
  format      String?
  order       Int
}

enum CustomIdType {
  FIXED
  RANDOM20
  RANDOM32
  RANDOM6
  RANDOM9
  GUID
  DATE
  SEQUENCE
}
